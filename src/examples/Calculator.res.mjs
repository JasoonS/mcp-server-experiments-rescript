// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "sury/src/S.res.mjs";
import * as MCP_SDK from "../MCP_SDK.res.mjs";
import * as Stdlib_Exn from "rescript/lib/es6/Stdlib_Exn.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let CalculationError = /* @__PURE__ */Primitive_exceptions.create("Calculator.CalculationError");

function registerCalculatorTool(server) {
  let calculatorSchema = S.object(s => ({
    a: s.f("a", S.refine(S.float, schema => (value => {
      if (!Number.isFinite(value)) {
        return schema.fail("First number must be finite", undefined);
      }
      
    }))),
    b: s.f("b", S.refine(S.float, schema => (value => {
      if (!Number.isFinite(value)) {
        return schema.fail("Second number must be finite", undefined);
      }
      
    }))),
    operation: s.f("operation", S.union([
      S.literal("Add"),
      S.literal("Subtract"),
      S.literal("Multiply"),
      S.literal("Divide")
    ]))
  }));
  let jsonSchema = S.toJSONSchema(calculatorSchema);
  let schemaShape = MCP_SDK.schemaToShape(jsonSchema);
  let performCalculation = params => {
    let match = params.operation;
    switch (match) {
      case "Add" :
        return params.a + params.b;
      case "Subtract" :
        return params.a - params.b;
      case "Multiply" :
        return params.a * params.b;
      case "Divide" :
        if (params.b === 0.0) {
          throw {
            RE_EXN_ID: CalculationError,
            _1: "DivisionByZero",
            Error: new Error()
          };
        }
        return params.a / params.b;
    }
  };
  server.tool("calculate", "Perform basic arithmetic operations", schemaShape, async params => {
    try {
      let result = performCalculation(params);
      if (!Number.isFinite(result)) {
        throw {
          RE_EXN_ID: CalculationError,
          _1: "OverUnderflow",
          Error: new Error()
        };
      }
      return {
        content: [{
            type_: "text",
            text: result.toString()
          }]
      };
    } catch (raw_jsExn) {
      let jsExn = Primitive_exceptions.internalToException(raw_jsExn);
      if (jsExn.RE_EXN_ID === CalculationError) {
        switch (jsExn._1) {
          case "DivisionByZero" :
            return {
              content: [{
                  type_: "text",
                  text: "Division by zero is not allowed"
                }],
              isError: true
            };
          case "InvalidOperation" :
            return {
              content: [{
                  type_: "text",
                  text: "Invalid operation"
                }],
              isError: true
            };
          case "OverUnderflow" :
            return {
              content: [{
                  type_: "text",
                  text: "Result is too large or small to represent"
                }],
              isError: true
            };
        }
      } else {
        if (jsExn.RE_EXN_ID === Stdlib_Exn.$$Error) {
          return {
            content: [{
                type_: "text",
                text: "Calculation error: " + Core__Option.getOr(jsExn._1.message, "Unknown error")
              }],
            isError: true
          };
        }
        throw jsExn;
      }
    }
  });
}

export {
  CalculationError,
  registerCalculatorTool,
}
/* S Not a pure module */
