// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Os from "os";
import * as Zod from "zod";
import * as Path from "path";
import * as Stdlib_Exn from "rescript/lib/es6/Stdlib_Exn.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Child_process from "child_process";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let Stats = {};

let Fs$1 = {
  Stats: Stats
};

function debugLog(message) {
  try {
    Fs.appendFileSync("./debug.log", message + "\n");
    return;
  } catch (exn) {
    return;
  }
}

let Path$1 = {};

let Os$1 = {};

let Buffer = {};

let ChildProcess = {};

let IndexerError = /* @__PURE__ */Primitive_exceptions.create("InitializeIndexer.IndexerError");

function directoryExists(path) {
  try {
    return Fs.statSync(path).isDirectory();
  } catch (exn) {
    return false;
  }
}

function createDirectoryRecursive(path) {
  try {
    if (!directoryExists(path)) {
      Fs.mkdirSync(path, {
        recursive: true
      });
      return;
    } else {
      return;
    }
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    let errorMsg = Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(exn), e => e.message), "Unknown error");
    throw {
      RE_EXN_ID: IndexerError,
      _1: {
        TAG: "DirectoryCreationError",
        _0: errorMsg
      },
      Error: new Error()
    };
  }
}

function registerInitializeIndexerTool(server) {
  let props = {
    name: Zod.z.string().min(1).describe("The name of the indexer project"),
    contractAddresses: Zod.z.array(Zod.z.string()).describe("Array of contract addresses to index (currently only supports one)"),
    networks: Zod.z.array(Zod.z.string()).describe("Array of blockchain networks to index from (currently only supports one)"),
    apiToken: Zod.z.string().min(1).describe("Your Hypersync API token"),
    language: Zod.z.enum([
      "javascript",
      "typescript",
      "rescript"
    ]).describe("Programming language for the indexer"),
    outputDirectory: Zod.z.string().nullish().describe("Optional: Directory to create the indexer in (defaults to ~/envio/<name-of-indexer>)")
  };
  let initializeIndexerSchema = Zod.z.object(props);
  server.tool("initialize_indexer", "Initialize an Envio indexer for a blockchain contract", initializeIndexerSchema.shape, async params => {
    try {
      debugLog("Received params: " + JSON.stringify(params));
      let name = params.name;
      let contractAddresses = params.contractAddresses;
      let networks = params.networks;
      let apiToken = params.apiToken;
      let language = params.language;
      debugLog("Processing outputDirectory");
      let dir = params.outputDirectory;
      let outputDirectory;
      if (dir == null) {
        debugLog("No outputDirectory provided (null/undefined)");
        let homeDir = Os.homedir();
        debugLog(Core__Option.getOr(JSON.stringify([
          homeDir,
          "envio",
          params.name
        ]), ""));
        debugLog("Using default path: " + Path.join(homeDir, "envio"));
        let path = Path.join(homeDir, "envio", params.name);
        debugLog("Using default path: " + path);
        outputDirectory = path;
      } else if (dir === "") {
        debugLog("Empty string in outputDirectory");
        let homeDir$1 = Os.homedir();
        let path$1 = Path.join(homeDir$1, "envio", params.name);
        debugLog("Using default path: " + path$1);
        outputDirectory = path$1;
      } else {
        debugLog("Using provided outputDirectory: " + dir);
        outputDirectory = dir;
      }
      if (contractAddresses.length === 0) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "At least one contract address must be provided"
          },
          Error: new Error()
        };
      }
      if (networks.length === 0) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "At least one network must be provided"
          },
          Error: new Error()
        };
      }
      if (contractAddresses.length > 1) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: "MultipleContractsNotSupported",
          Error: new Error()
        };
      }
      if (networks.length > 1) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: "MultipleNetworksNotSupported",
          Error: new Error()
        };
      }
      let address = contractAddresses[0];
      let contractAddress;
      if (address !== undefined) {
        contractAddress = address;
      } else {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "No contract address provided"
          },
          Error: new Error()
        };
      }
      let network = networks[0];
      let network$1;
      if (network !== undefined) {
        network$1 = network;
      } else {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "No network provided"
          },
          Error: new Error()
        };
      }
      debugLog("Creating directory: " + outputDirectory);
      createDirectoryRecursive(outputDirectory);
      let command = "pnpx envio init contract-import explorer -n " + name + " -l " + language + " -d " + outputDirectory + " -c " + contractAddress + " -b " + network$1 + " --api-token " + apiToken;
      debugLog("Executing command: " + command);
      debugLog("\n======= MANUAL TEST SCRIPT =======\nTo test this command manually, you can run:\n\ncd /tmp\nmkdir -p test-envio-indexer\ncd test-envio-indexer\n\n# Then run the command:\n" + command + "\n\n# IMPORTANT: The CLI may require pressing Enter key TWICE during execution\n# to confirm options or proceed through interactive prompts\n\n# Alternatives to try if above doesn't work:\n# - pnpx envio init (then answer prompts interactively)\n# - echo '\n\n' | " + command + " (pipe multiple newlines)\n======= END TEST SCRIPT =======\n");
      try {
        debugLog("Attempting to execute command with interactive input");
        let processOptions = {
          encoding: "utf8",
          stdio: [
            "pipe",
            "pipe",
            "pipe"
          ],
          input: "\n\n\n\n",
          shell: true,
          timeout: 120000
        };
        debugLog("Executing with input of multiple Enter keypresses");
        let result = Child_process.execSync(command, processOptions);
        debugLog("Command output: " + result);
        debugLog("Command executed successfully");
        return {
          content: [{
              type: "text",
              text: "Successfully initialized Envio indexer \"" + name + "\" in " + outputDirectory
            }]
        };
      } catch (raw_exn) {
        let exn = Primitive_exceptions.internalToException(raw_exn);
        let errorMsg = Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(exn), e => e.message), "Unknown error");
        debugLog("Command execution failed: " + errorMsg);
        try {
          debugLog("Trying fallback with echo pipe approach");
          let echoPipeCommand = "echo -e '\\n\\n\\n\\n' | " + command;
          debugLog("Echo pipe command: " + echoPipeCommand);
          let result$1 = Child_process.execSync(echoPipeCommand, {
            encoding: "utf8",
            stdio: "pipe",
            shell: true
          });
          debugLog("Fallback command output: " + result$1);
          debugLog("Command executed successfully via fallback");
          return {
            content: [{
                type: "text",
                text: "Successfully initialized Envio indexer \"" + name + "\" in " + outputDirectory
              }]
          };
        } catch (raw_fallbackExn) {
          let fallbackExn = Primitive_exceptions.internalToException(raw_fallbackExn);
          let fallbackErrorMsg = Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(fallbackExn), e => e.message), "Unknown error");
          debugLog("Fallback execution also failed: " + fallbackErrorMsg);
          throw {
            RE_EXN_ID: IndexerError,
            _1: {
              TAG: "CommandExecutionError",
              _0: errorMsg + "\nFallback also failed: " + fallbackErrorMsg
            },
            Error: new Error()
          };
        }
      }
    } catch (raw_exn$1) {
      let exn$1 = Primitive_exceptions.internalToException(raw_exn$1);
      if (exn$1.RE_EXN_ID !== IndexerError) {
        return {
          content: [{
              type: "text",
              text: "Unexpected error: " + Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(exn$1), e => e.message), "Unknown error")
            }],
          isError: true
        };
      }
      let msg = exn$1._1;
      if (typeof msg !== "object") {
        if (msg === "MultipleContractsNotSupported") {
          return {
            content: [{
                type: "text",
                text: "Multiple contracts are not yet supported. Please provide only one contract address."
              }],
            isError: true
          };
        } else {
          return {
            content: [{
                type: "text",
                text: "Multiple networks are not yet supported. Please provide only one network."
              }],
            isError: true
          };
        }
      }
      switch (msg.TAG) {
        case "InvalidParams" :
          return {
            content: [{
                type: "text",
                text: "Invalid parameters: " + msg._0
              }],
            isError: true
          };
        case "CommandExecutionError" :
          return {
            content: [{
                type: "text",
                text: "Error executing envio init command: " + msg._0
              }],
            isError: true
          };
        case "DirectoryCreationError" :
          return {
            content: [{
                type: "text",
                text: "Error creating directory: " + msg._0
              }],
            isError: true
          };
      }
    }
  });
}

export {
  Fs$1 as Fs,
  debugLog,
  Path$1 as Path,
  Os$1 as Os,
  Buffer,
  ChildProcess,
  IndexerError,
  directoryExists,
  createDirectoryRecursive,
  registerInitializeIndexerTool,
}
/* fs Not a pure module */
