// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Os from "os";
import * as Zod from "zod";
import * as Path from "path";
import * as Stdlib_Exn from "rescript/lib/es6/Stdlib_Exn.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Child_process from "child_process";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

let Stats = {};

let Fs$1 = {
  Stats: Stats
};

function debugLog(message) {
  try {
    let timestamp = Date.now().toString();
    Fs.appendFileSync("debug.log", "[" + timestamp + "] " + message + "\n");
    return;
  } catch (exn) {
    return;
  }
}

let Path$1 = {};

let Os$1 = {};

let Buffer = {};

let ChildProcess = {};

let IndexerError = /* @__PURE__ */Primitive_exceptions.create("InitializeIndexer.IndexerError");

function directoryExists(path) {
  try {
    return Fs.statSync(path).isDirectory();
  } catch (exn) {
    return false;
  }
}

function createDirectoryRecursive(path) {
  try {
    if (!directoryExists(path)) {
      Fs.mkdirSync(path, {
        recursive: true
      });
      return;
    } else {
      return;
    }
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    let errorMsg = Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(exn), e => e.message), "Unknown error");
    throw {
      RE_EXN_ID: IndexerError,
      _1: {
        TAG: "DirectoryCreationError",
        _0: errorMsg
      },
      Error: new Error()
    };
  }
}

function getScriptPath() {
  let scriptDir = Path.resolve("./src");
  return Path.join(scriptDir, "initilazize.sh");
}

function registerInitializeIndexerTool(server) {
  let props = {
    name: Zod.z.string().min(1).describe("The name of the indexer project"),
    contractAddresses: Zod.z.array(Zod.z.string()).describe("Array of contract addresses to index (currently only supports one)"),
    networks: Zod.z.array(Zod.z.string()).describe("Array of blockchain networks to index from (currently only supports one)"),
    apiToken: Zod.z.string().min(1).describe("Your Hypersync API token"),
    language: Zod.z.enum([
      "javascript",
      "typescript",
      "rescript"
    ]).describe("Programming language for the indexer"),
    outputDirectory: Zod.z.string().nullish().describe("Optional: Directory to create the indexer in (defaults to ~/envio/<name-of-indexer>)")
  };
  let initializeIndexerSchema = Zod.z.object(props);
  server.tool("initialize_indexer", "Initialize an Envio indexer for a blockchain contract", initializeIndexerSchema.shape, async params => {
    try {
      debugLog("Received params: " + JSON.stringify(params));
      let name = params.name;
      let contractAddresses = params.contractAddresses;
      let networks = params.networks;
      let apiToken = params.apiToken;
      let language = params.language;
      debugLog("Processing outputDirectory");
      let dir = params.outputDirectory;
      let outputDirectory;
      if (dir == null) {
        debugLog("No outputDirectory provided (null/undefined)");
        let homeDir = Os.homedir();
        debugLog(Core__Option.getOr(JSON.stringify([
          homeDir,
          "envio",
          params.name
        ]), ""));
        debugLog("Using default path: " + Path.join(homeDir, "envio"));
        let path = Path.join(homeDir, "envio", params.name);
        debugLog("Using default path: " + path);
        outputDirectory = path;
      } else if (dir === "") {
        debugLog("Empty string in outputDirectory");
        let homeDir$1 = Os.homedir();
        let path$1 = Path.join(homeDir$1, "envio", params.name);
        debugLog("Using default path: " + path$1);
        outputDirectory = path$1;
      } else {
        debugLog("Using provided outputDirectory: " + dir);
        outputDirectory = dir;
      }
      if (contractAddresses.length === 0) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "At least one contract address must be provided"
          },
          Error: new Error()
        };
      }
      if (networks.length === 0) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "At least one network must be provided"
          },
          Error: new Error()
        };
      }
      if (contractAddresses.length > 1) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: "MultipleContractsNotSupported",
          Error: new Error()
        };
      }
      if (networks.length > 1) {
        throw {
          RE_EXN_ID: IndexerError,
          _1: "MultipleNetworksNotSupported",
          Error: new Error()
        };
      }
      let address = contractAddresses[0];
      let contractAddress;
      if (address !== undefined) {
        contractAddress = address;
      } else {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "No contract address provided"
          },
          Error: new Error()
        };
      }
      let network = networks[0];
      let network$1;
      if (network !== undefined) {
        network$1 = network;
      } else {
        throw {
          RE_EXN_ID: IndexerError,
          _1: {
            TAG: "InvalidParams",
            _0: "No network provided"
          },
          Error: new Error()
        };
      }
      let scriptPath = getScriptPath();
      createDirectoryRecursive(outputDirectory);
      let command = scriptPath + " --name \"" + name + "\" --language " + language + " --output-dir \"" + outputDirectory + "\" --contract-address " + contractAddress + " --network " + network$1 + " --api-token \"" + apiToken + "\"";
      debugLog("Executing command: " + command);
      try {
        Child_process.execSync("chmod +x " + scriptPath, {
          encoding: "utf8",
          stdio: "pipe"
        });
        let result = Child_process.execSync(command, {
          encoding: "utf8",
          stdio: "pipe",
          timeout: 300000
        });
        return {
          content: [{
              type: "text",
              text: result.trim()
            }]
        };
      } catch (raw_exn) {
        let exn = Primitive_exceptions.internalToException(raw_exn);
        let errorMsg = Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(exn), e => e.message), "Unknown error");
        debugLog("Command execution failed: " + errorMsg);
        try {
          debugLog("Trying fallback with alternative approach");
          let yesCommand = "yes \"\" | head -n 10 | (sleep 2 && cat) | " + command;
          debugLog("Yes command: " + yesCommand);
          let result$1 = Child_process.execSync(yesCommand, {
            encoding: "utf8",
            stdio: "pipe",
            shell: true,
            timeout: 300000
          });
          debugLog("Fallback command output: " + result$1);
          debugLog("Command executed successfully via fallback");
          return {
            content: [{
                type: "text",
                text: "Successfully initialized Envio indexer \"" + name + "\" in " + outputDirectory
              }]
          };
        } catch (raw_fallbackExn) {
          let fallbackExn = Primitive_exceptions.internalToException(raw_fallbackExn);
          let fallbackErrorMsg = Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(fallbackExn), e => e.message), "Unknown error");
          debugLog("Fallback execution also failed: " + fallbackErrorMsg);
          let errorDetails = "\nCommand attempted: " + command + "\nPrimary error: " + errorMsg + "\nFallback error: " + fallbackErrorMsg + "\n\nPossible solutions:\n1. Try running the command manually to see the interactive prompts\n2. Check if the envio CLI has a non-interactive mode or configuration options\n3. Consider using a dedicated automation tool like 'expect' if available\n";
          debugLog(errorDetails);
          throw {
            RE_EXN_ID: IndexerError,
            _1: {
              TAG: "CommandExecutionError",
              _0: errorDetails
            },
            Error: new Error()
          };
        }
      }
    } catch (raw_exn$1) {
      let exn$1 = Primitive_exceptions.internalToException(raw_exn$1);
      if (exn$1.RE_EXN_ID !== IndexerError) {
        return {
          content: [{
              type: "text",
              text: "Unexpected error: " + Core__Option.getOr(Core__Option.flatMap(Stdlib_Exn.asJsExn(exn$1), e => e.message), "Unknown error")
            }],
          isError: true
        };
      }
      let msg = exn$1._1;
      if (typeof msg !== "object") {
        if (msg === "MultipleContractsNotSupported") {
          return {
            content: [{
                type: "text",
                text: "Multiple contracts are not yet supported. Please provide only one contract address."
              }],
            isError: true
          };
        } else {
          return {
            content: [{
                type: "text",
                text: "Multiple networks are not yet supported. Please provide only one network."
              }],
            isError: true
          };
        }
      }
      switch (msg.TAG) {
        case "InvalidParams" :
          return {
            content: [{
                type: "text",
                text: "Invalid parameters: " + msg._0
              }],
            isError: true
          };
        case "CommandExecutionError" :
          return {
            content: [{
                type: "text",
                text: "Error executing envio init command: " + msg._0
              }],
            isError: true
          };
        case "DirectoryCreationError" :
          return {
            content: [{
                type: "text",
                text: "Error creating directory: " + msg._0
              }],
            isError: true
          };
      }
    }
  });
}

export {
  Fs$1 as Fs,
  debugLog,
  Path$1 as Path,
  Os$1 as Os,
  Buffer,
  ChildProcess,
  IndexerError,
  directoryExists,
  createDirectoryRecursive,
  getScriptPath,
  registerInitializeIndexerTool,
}
/* fs Not a pure module */
